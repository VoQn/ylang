(module Data.List)

; # Test whether a list is empty.
(nil? : [a] -> Bool)
(nil? [] = Yes)
(nil? _  = No)

;; # O(n) 'length' return the length of a finite list as an 'Nat'.
(length : [a] -> Nat)
(length xs = len-acc xs 0u)

(len-acc : [a] -> Nat -> Nat)
(len-acc []       n = n)
(len-acc (_ , xs) n = len-acc xs $ succ n)

(inc-len : Nat -> a -> Nat)
(inc-len x _ = succ x)

(fusion-rule
  (length
    :phase (~ 1)
    :for-all [xs]
    :redef (length xs = foldr inc-len 0 xs))

  (lengthList
    :phase 1
    :redef (foldr inc-len 0 = len-acc)))

;; 'filter', applied to a predicate and a list, returns the list of
;; those elements that satisfy the predicate; i.e.,
(filter : (a -> Bool) -> [a] -> [a])
(filter _ [] = [])
(filter pred (x , xs) =
  if (pred x) (x , filter pred xs)
              (filter pred xs))

(filterFB : (a -> b -> b) -> (a -> Bool) -> a -> b -> b)
(filterFB c p x r = if (p x) (x `c` r) r)

(fusion-rule
  (filter
    :phase (~ 1)
    :for-all [p xs]
    :redef (filter p xs = build $ (c n) -> (foldr (filterFB c p) n xs)))

  (filterList
    :phase 1
    :for-all [p]
    :redef (foldr (filterFB (,) p) [] = filter p))

  (filterFB
    :for-all [c p q]
    :redef (filterFB (filterFB c p) q = filterFB c $ (x) -> q x && p x)))

;; 'foldl', applied to a binary operator, a starting value (typically
;; the left-identity of the operator), and a list, reduces the list
;; using the binary operator, from left to right:
(foldl : (b -> a -> b) -> b -> [a] -> b)
(foldl f z xs = (foldr track id xs $ z)
  (where (track : a -> (b -> b) -> b -> b)
         (track x g = (n) -> g $ f n x)))
